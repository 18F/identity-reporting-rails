# Jobs defined here use the idp/ci docker image from ECR by default. To find
# other available images:
# aws ecr describe-repositories | jq '.repositories[].repositoryUri'
# Images are built via the identity-devops GitLab pipeline.

variables:
  GITLAB_CI: 'true'
  ECR_REGISTRY: '${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com'
  IDP_CI_SHA: 'sha256:0cea6ebf8fa4d693177f46ae9a8c24e6030245f3c795753269b7910178d5cfdd'
  JUNIT_OUTPUT: 'true'
  DS_IMAGE_SUFFIX: "-fips"

default:
  image: '${ECR_REGISTRY}/idp/ci@${IDP_CI_SHA}'

.bundle_install: &bundle_install
  - bundle check || bundle install --deployment --jobs=4 --retry=3 --without deploy development doc production --path vendor/ruby

.build_cache:
  - &ruby_cache
    key:
      files:
        - Gemfile.lock
    paths:
      - vendor/ruby
    policy: pull

stages:
  - build
  - test
  - after_test
  - release

workflow:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" || $CI_PIPELINE_SOURCE == "external_pull_request_event"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" || $CI_PIPELINE_SOURCE == "external_pull_request_event" || $CI_PIPELINE_SOURCE == "web"'
    - if: '$CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "stages/prod"'
    - if: '$CI_MERGE_REQUEST_IID || $CI_EXTERNAL_PULL_REQUEST_IID'

install:
  stage: build
  variables:
    RAILS_ENV: test
  cache:
    - <<: *ruby_cache
      policy: pull-push

  script:
    - *bundle_install

specs:
  stage: test
  needs:
    - job: install
  parallel: 22
  cache:
    - <<: *ruby_cache
  variables:
    AWS_ACCESS_KEY_ID: test
    AWS_DEFAULT_REGION: us-west-2
    AWS_REGION: us-west-2
    AWS_SECRET_ACCESS_KEY: test
    COVERAGE: 'true'
    DOCKER_DB_HOST: db-postgres
    POSTGRES_DB: identity_reporting_rails_test
    POSTGRES_USER: postgres_user
    POSTGRES_PASSWORD: postgres_password
    POSTGRES_HOST_AUTH_METHOD: trust
    RAILS_ENV: test
  services:
    - name: postgres:13
      alias: db-postgres
      command: ['--fsync=false', '--synchronous_commit=false', '--full_page_writes=false']
  artifacts:
    expire_in: 31d
    when: always
    paths:
      - coverage/
      - rspec.xml
      - rspec_json/
    reports:
      junit: rspec.xml
  script:
    - *bundle_install
    - cp config/application.yml.default config/application.yml
    - bundle exec rake db:create db:migrate --trace
    - bundle exec rake db:seed
    - bundle exec rake knapsack:rspec["--format documentation --format RspecJunitFormatter --out rspec.xml --format json --out rspec_json/${CI_NODE_INDEX}.json"]

lint:
  stage: test
  needs:
    - job: install
  cache:
    - <<: *ruby_cache
  script:
    - *bundle_install
    - make lint
  artifacts:
    expire_in: 31d
    when: always
    paths:
      - rubocop.xml
    reports:
      junit: rubocop.xml

coverage:
  stage: after_test
  cache:
    - <<: *ruby_cache
  script:
    - *bundle_install
    - bundle exec spec/simplecov_merger.rb
    - mv coverage/coverage/* coverage/
  coverage: '/Coverage report generated for .* LOC \((\d\d.\d\d\%)\).*$/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/coverage.xml
    name: coverage
    expire_in: 31d
    paths:
      - rspec_json/rspec.json
      - knapsack_rspec_report.json
      - coverage/index.html
      - coverage/assets/
      - coverage/coverage.xml

require_git_trailer:
  stage: test
  needs: []
  variables:
    GIT_STRATEGY: clone
  script:
    - |
      git fetch origin $CI_COMMIT_REF_NAME
      git fetch origin $CI_DEFAULT_BRANCH
      git checkout $CI_COMMIT_REF_NAME
      FIRST_COMMIT=$(git rev-list --first-parent "origin/main..HEAD" | tail -n 1)
      if ! git show --format='%B' "$FIRST_COMMIT" | grep -E "^Changelog:"; then
        echo "ERROR: The first commit ($FIRST_COMMIT) does not contain a changelog entry"
        exit 1
      fi
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

pre_release:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  script:
    - |
      glab auth login --hostname gitlab.login.gov --job-token $CI_JOB_TOKEN
      echo "Fetching list of releases..."
      RELEASES=$(glab release list --per-page 3)
      RELEASES_COUNT=$(echo "$RELEASES" | wc -l)
      if [ "$RELEASES_COUNT" -lt 3 ]; then
        echo "No releases were found."
      else
        echo "Filtering to latest..."
        LATEST_RELEASE=$(echo "$RELEASES" | tail -n +3 | awk '{print $1}' | grep -v "pre-" | head -1)
        echo "Latest Release: $LATEST_RELEASE"
      fi
      if [ -z "$LATEST_RELEASE" ]; then
        echo "No previous release found. Assuming changelogs are not available. Starting from v1";
        NEW_RELEASE="pre-v1";
        echo "Manual changelog generation required." > changelog.md
      else
        NEW_RELEASE=$(echo "$LATEST_RELEASE" | awk -F. '{printf "pre-v%d", $1+1}')
        glab release changelog --since="$LATEST_RELEASE" --output changelog.md
      fi
      glab release create "$NEW_RELEASE" --ref "$CI_COMMIT_SHA" --notes-file changelog.md
      cat "$NEW_RELEASE" > pre-release-tag.txt
  artifacts:
    paths:
      - pre-release-tag.txt
      - changelog.md
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

promote_release:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  dependencies:
    - pre_release
  script:
    - |
      glab auth login --hostname gitlab.login.gov --job-token $CI_JOB_TOKEN
      echo "Promoting release..."
      PRE_RELEASE=$(cat pre-release-tag.txt)
      NEW_RELEASE=$(echo "$PRE_RELEASE" | sed s/pre-//)
      glab release create "$NEW_RELEASE" --target "$CI_COMMIT_SHA" --notes-file changelog.md
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual

include:
  - template: Jobs/SAST.latest.gitlab-ci.yml
  - template: Jobs/Secret-Detection.latest.gitlab-ci.yml
  - template: Jobs/Dependency-Scanning.latest.gitlab-ci.yml

audit_packages_scheduled:
  stage:
    test
  needs:
    - job: install
  cache:
    - <<: *ruby_cache
  script:
    - *bundle_install
    - make audit
  after_script:
    - |-
      if [ "$CI_JOB_STATUS" != "success" ]; then
        ./scripts/notify-slack \
          --icon ":gitlab:"  \
          --username "gitlab-notify" \
          --channel "#login-team-agnes" \
          --webhook "${SLACK_WEBHOOK}" \
          --raise \
          --text "$(printf "Dependencies audit in GitLab failed.\nBuild Results: ${CI_JOB_URL}\nCheck results locally with 'make audit'")"
      fi
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
